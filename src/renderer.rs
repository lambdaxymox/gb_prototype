use gl_backend::GLState;


/// Determine whether to create a uniform buffer or a general vertex storage buffer.
enum BufferStorageType {
    Storage,
    Uniform,
}

/// The shape of the data.
struct BufferLayout {
    offset: Offset,
    stride: Stride,
    size: Size,
    ty: Type
}

/// The entry point into a shader.
struct EntryPoint {
    name: String,
    shader: ShaderIndex,
    index: ShaderVariableIndex
}
/// The association between a buffer slice and an input variable for a shader.
struct BufferBinding {
    index: BufferIndex,
    entry: EntryPoint
}

/// A buffer consists of an index and a layout.
struct Buffer {
    index: BufferIndex,
    ty: BufferStorageType, 
    layout: BufferLayout,
}
/// A descriptor describes the relationship between a buffer or sampler and a shader variable (attribute).
/// In particular, it associates a shader variable with a buffer or a texture sampler.
enum DescriptorType {
    Buffer,
    Sampler,
}

struct Descriptor {
    ty: DescriptorType,
    buffer_index: BufferIndex,
    shader_variable: ShaderIndex,
}
/// A DescriptorSet describes the relationship between a set of buffers and a set of shader attributes.
struct DescriptorSet {
    index: DescriptorSetIndex,
    descriptors: HashMap<Descriptor>,
}


/// An index to the texture sample entry.
struct SamplerIndex(u32);
/// An index to the buffer entry.
struct BufferIndex(u32);
/// An index to the shader entry.
struct ShaderIndex(u32);
/// An index to the shader vertex entry.
struct ShaderVariableIndex(u32);
/// An index to a set of vertex attibute objects associated together
/// from a DescriptorSet. (vao). These are generated by the renderer.
struct DescriptorSetIndex(u32);


enum Command {
    CompileShader,
    LoadBuffer,
    Draw,
    CreateBuffer,
    LoadSampler,
    LoadDescriptorSet,
}

struct CompilerShaderCommand {
    source: ShaderSource,
}

struct CreateBufferCommand {
    ty: BufferStorageType, 
    layout: BufferLayout,
}

struct LoadBufferCommand {
    data: &[u8],
    width: u32,
    height: u32,
    buffer: BufferIndex,
}

struct LoadSamplerCommand {
    buffer: BufferIndex,
}

struct LoadDescriptorSetCommand {
    set: DescriptorSet,
}

struct DrawCommand {
    index: DescriptorSetIndex,
}


struct Renderer {
    queue: Vec<Command>,
    shaders: HashMap<ShaderIndex, Shader>,
    buffers: HashMap<BufferIndex, Buffer>,
    bindings: HashMap<BufferIndex, EntryPoint>,
    descriptors: HashMap<DescriptorSetIndex, DescriptorSet>,
    backend: RendererBackend,
}

impl Renderer {
    fn enqueue(&mut self, command: Command) {
        self.queue.push(command);
    }

    fn clear_command_queue(&mut self) {
        self.queue.clear();
    }

    fn render(&mut self) {
        for command in self.queue.iter() {
            match command {
                Command::CompilerShader(c) => {
                    self.backend.compile_shader()
                }
            }
        }
    }
}


struct GLBufferIndex(GLuint);
struct GLShaderIndex(GLuint);
struct GLShaderVariableIndex(GLuint);

struct RendererBackend {
    context: glh::GLState,
}

impl RendererBackend {
    fn compiler_shader(&mut self) -> GLShaderIndex {
        let mut vert_reader = io::Cursor::new(source.vert_source);
        let mut frag_reader = io::Cursor::new(source.frag_source);
        let sp = gl_backend::create_program_from_reader(
            &mut self.context,
            &mut vert_reader, source.vert_name,
            &mut frag_reader, source.frag_name
        ).unwrap();
        debug_assert!(sp > 0);
    
        GLShaderIndex(sp)
    }
}
